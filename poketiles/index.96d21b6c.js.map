{"mappings":"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","sources":["src/poketiles/index.js"],"sourcesContent":["// GLOBAL VARIABLES\nconst POKEMON_SPECIES_URL = `https://pokeapi.co/api/v2/pokemon-species?limit=100000&offset=0`;\n\nconst BETWEEN_ROUND_DELAY_MS = 700;\nconst MAX_TIME_PER_ROUND_S = 10;\nconst MIN_TIME_PER_ROUND_S = 4;\nconst NUM_TILES = 4;\n\nlet pokemonDataArr = null;\nlet indexArrShuffled = null;\nlet numTilesFilled = 0;\nlet roundCount= 0;\nlet currentTileElmArr = [];\n\n// UI Elements\nconst currentScoreElm = document.getElementById('current-score');\nconst bestScoreElm = document.getElementById('best-score');\nconst targetGridElm = document.getElementById('poke-tile-table');\nconst tileContainerElm = document.getElementById('poke-img-set');\nconst timeTrackerElm = document.getElementById('time-tracker');\nconst gameElm = document.getElementById('game');\n\n// fetches data from pokeapi\nconst fetchPokemonSpeciesDataAsync = async () => {\n    const res = await fetch(POKEMON_SPECIES_URL);\n    const data = await res.json();\n    return data;\n}\n\n// initializes in-game pokemon data\nconst initPokemonDataArrAsync = async () => {\n    const data = await fetchPokemonSpeciesDataAsync();\n    const tempLength = data.results.length;\n    pokemonDataArr = data.results.slice(0,tempLength).map((pokemon,index) => {\n        return {\n            name: pokemon.name,\n            id: index+1\n        };\n    });\n    indexArrShuffled = generateIndexArr(tempLength);\n    shuffleArr(indexArrShuffled);\n    cachePokemonSprites();\n}\n\n// starts the next round of the game\nconst startNextRound = () => {\n    // clears the target grid and tile container of current round\n    clearTargetGridAndTileContainer();\n\n    numTilesFilled = 0;\n    roundCount++;\n    cachePokemonSprites();\n\n    [offsetStart,offsetEnd] = calculateOffset();\n\n    // setup targets and tiles for pokemon of current round\n    const pokemonIdArr = indexArrShuffled.slice(offsetStart,offsetEnd);\n    setupTargetGrid(pokemonIdArr);\n    cachePokemonAudio(pokemonIdArr);\n    shuffleArr(pokemonIdArr);\n    setupTileContainer(pokemonIdArr);\n\n    // start countdown for time tracker\n    startTimer();\n}\n\n// calculates the offset for the pokemon index array\nconst calculateOffset = () => {\n    let offsetStart = (roundCount - 1) * NUM_TILES;\n    let offsetEnd = offsetStart + NUM_TILES;\n    if (offsetEnd > pokemonDataArr.length) {\n        offsetStart = 0;\n        offsetEnd = offsetStart + NUM_TILES;\n    }\n    return [offsetStart,offsetEnd];\n}\n\n// creates an array of ids for the (4) pokemon of the current round\nconst generatePokemonIdArr = (numTotalPokemon) => {\n    const indexArr = generateIndexArr(numTotalPokemon);\n    const pokemonIdArr = shuffleArr(indexArr).slice(0,NUM_TILES);\n    return pokemonIdArr;\n}\n\n// creates an array containing values from 1 to length\nconst generateIndexArr = (length) => {\n    const indexArr = [];\n    for (let i=1; i<=length; i++) {\n        indexArr.push(i);\n    }\n    return indexArr;\n}\n\n// shuffles the positions of elements in the given array\nconst shuffleArr = (arr) => {\n    let currentIndex = arr.length,  randomIndex;\n  \n    // While there remain elements to shuffle.\n    while (currentIndex != 0) {\n  \n      // Pick a remaining element.\n      randomIndex = Math.floor(Math.random() * currentIndex);\n      currentIndex--;\n  \n      // And swap it with the current element.\n      [arr[currentIndex], arr[randomIndex]] = [\n        arr[randomIndex], arr[currentIndex]];\n    }\n    return arr;\n}\n\n// populates the target grid with new target pokemon names\nconst setupTargetGrid = (pokemonIdArr) => {\n    for (let row=0; row<2; row++) {\n        const targetRowElm = document.createElement('tr');\n        for (let col=0; col<2; col++) {\n            const targetCellElm = document.createElement('td');\n        \n            const randomId = pokemonIdArr[row*2 + col];\n\n            targetCellElm.id = `poke-title-${randomId}`;\n            targetCellElm.innerText = pokemonDataArr[randomId-1].name.toUpperCase();\n            targetCellElm.ondragover = handleOnDragOver;\n            targetCellElm.ondrop = handleOnDrop;\n\n            targetRowElm.appendChild(targetCellElm);\n        }\n        targetGridElm.appendChild(targetRowElm);\n    }\n}\n\n// populates the tile container with new pokemon tiles\nconst setupTileContainer = (pokemonIdArr) => {\n    let tileElmArr = [];\n    for (let i=0; i<4; i++) {\n        const randomId = pokemonIdArr[i];\n\n        const tileImgElm = document.createElement('img');\n        tileImgElm.src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${randomId}.png`;\n        tileImgElm.draggable = false;\n\n        const tileElm = document.createElement('div');\n        tileElm.id = `poke-img-${randomId}`;\n        tileElm.classList.add('poke-img');\n        \n        tileElm.draggable = true;\n        tileElm.ondragstart = handleOnDragStart;\n\n        tileElm.appendChild(tileImgElm);\n        addSilhouette(tileElm);\n\n        tileContainerElm.appendChild(tileElm);\n        \n        tileElmArr.push(tileElm);\n    }\n    currentTileElmArr = tileElmArr;\n}\n\n// clears the contents of the target grid and tile container\nconst clearTargetGridAndTileContainer = () => {\n    targetGridElm.style.backgroundColor = 'white';\n    targetGridElm.innerHTML = \"\";\n    tileContainerElm.innerHTML = \"\";\n}\n\n// starts the timer and its corresponding animation\nconst startTimer = () => {\n    let currentRoundCount = roundCount;\n    setTimeout(() => {\n        if(currentRoundCount === roundCount && numTilesFilled < NUM_TILES) {\n            shuffleArr(indexArrShuffled);\n            cachePokemonSprites();\n            setPreGameState();\n        }\n    }, getTimeForCurrentRound()*1000);\n    startTimerAnimation();\n}\n\n// creates and starts the timer animation\nconst startTimerAnimation = () => {\n    const fillElm = document.createElement('div');\n\n    fillElm.classList.add('fill');\n    fillElm.style.animation = `decrease-fill ${getTimeForCurrentRound()}s linear`;\n\n    timeTrackerElm.innerHTML = \"\";\n    timeTrackerElm.appendChild(fillElm);\n}\n\n// adds blur to the game board\nconst blurGameBoard = () => {\n    gameElm.style.filter = 'blur(4px)';\n    gameElm.style.pointerEvents = 'none';\n}\n\n// removes blur from the game board\nconst unblurGameBoard = () => {\n    gameElm.style.filter = 'blur(0)';\n    gameElm.style.pointerEvents = 'all';\n}\n\n// adds a click event listener to the page\nconst docClickListener = () => {\n    if (roundCount === 0 && pokemonDataArr !== null) {\n        document.removeEventListener('mouseup', docClickListener);\n        setInGameState();\n        startNextRound();\n    }\n}\n\n// displays the \"click to play\" modal\nconst showClickToPlay = () => {\n    const preGameModalElm = document.createElement('div');\n    preGameModalElm.id = 'pre-game-modal'\n    preGameModalElm.classList.add(preGameModalElm.id);\n\n    const modalContentElm = document.createElement('div');\n    modalContentElm.classList.add('content');\n    modalContentElm.innerText = \"Click Anywhere To Start\";\n\n    preGameModalElm.appendChild(modalContentElm);\n    document.body.appendChild(preGameModalElm);\n}\n\n// removes the \"click to play\" modal\nconst removeClickToPlay = () => {\n    const preGameModalElm = document.getElementById('pre-game-modal');\n    preGameModalElm.remove();\n}\n\n// sets the page up to be ready to start a new game\nconst setPreGameState = () => {\n    roundCount = 0;\n    numTilesFilled = 0;\n    \n    blurGameBoard();\n    document.addEventListener('mouseup', docClickListener);\n    showClickToPlay();\n}\n\n// sets the page up to be in the start of a new game\nconst setInGameState = () => {\n    updateScore()\n    unblurGameBoard();\n    removeClickToPlay();\n}\n\n// determines whether the current round is complete\nconst roundComplete = () => {\n    return numTilesFilled === NUM_TILES;\n}\n\n// calculates and returns the provided time for the current round\nconst getTimeForCurrentRound = () => {\n    const expectedTime = MAX_TIME_PER_ROUND_S - 1.5*(roundCount-1);\n    const actualTime = expectedTime < MIN_TIME_PER_ROUND_S ? MIN_TIME_PER_ROUND_S : expectedTime;\n    return actualTime;\n}\n\n// caches the images for the pokemon of the next round\nconst cachePokemonSprites = () => {\n    [offsetStart,offsetEnd] = calculateOffset();\n    for (let i=1; i<=NUM_TILES; i++) {\n        const imgElm = document.createElement('img');\n        imgElm.src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${indexArrShuffled[i+offsetEnd]}.png`;\n    }\n}\n\n// caches all the pokemon audio used for the current round\nconst cachePokemonAudio = (pokemonIdArr) => {\n    pokemonIdArr.forEach(pokemonId => {\n        playPokemonCryAudio(pokemonId,true);\n    });\n    playPokemonNotificationAudio(true);\n}\n\n// plays the cry audio of the pokemon of the specified id\nconst playPokemonCryAudio = (pokemonId,isMuted) => {\n    const pokemonName = pokemonDataArr[pokemonId-1].name;\n    const audio = new Audio(`https://play.pokemonshowdown.com/audio/cries/${pokemonName}.mp3`);\n    audio.muted = isMuted;\n    audio.play();\n}\n\n// plays the pokemon notification audio\nconst playPokemonNotificationAudio = (isMuted) => {\n    const audio = new Audio(`https://play.pokemonshowdown.com/audio/notification.wav`);\n    audio.muted = isMuted;\n    audio.play();\n}\n\n// event handler for when dragging tiles\nconst handleOnDragStart = (ev) => {\n    ev.dataTransfer.setData(\"text/plain\", ev.target.id);\n};\n\n// event handler for when a tile is placed over a target\nconst handleOnDragOver = (ev) => {\n    ev.preventDefault();\n};\n\n// event handler for when a tile is released on top of a target\nconst handleOnDrop = (ev) => {\n    if (ev.dataTransfer !== null) {\n        const targetElm = ev.target;\n\n        const tileElmId = ev.dataTransfer.getData(\"text/plain\");\n        const tileElm = document.getElementById(tileElmId);\n\n        if (!targetAndTileMatch(targetElm,tileElm)) {\n            handleIncorrectMatch(tileElm);\n            return;\n        }\n        else {\n            handleCorrectMatch(targetElm,tileElm);\n        }\n\n        if (roundComplete()) {\n            updateScore();\n            removeTileOutlines();\n            // resets for new game\n            setTimeout(startNextRound,BETWEEN_ROUND_DELAY_MS);\n        }\n    }    \n}\n\n// determines whether the provided target and tile are for the same pokemon\nconst targetAndTileMatch = (targetElm,tileElm) => {\n    const targetId = targetElm.id;\n    const tileId = tileElm.id;\n\n    const targetPokemonId = targetId.split(\"-\")[2];\n    const tilePokemonId = tileId.split(\"-\")[2];\n\n    return targetPokemonId === tilePokemonId;\n}\n\n// performs all necessary work for an incorrect tile match\nconst handleIncorrectMatch = (tileElm) => {\n    const pokemonId = tileElm.id.split(\"-\")[2];\n    playPokemonCryAudio(pokemonId, false);\n\n    tileElm.classList.add('shake');\n    tileElm.draggable = false;\n    setTimeout(() => {\n        tileElm.classList.remove('shake');\n        tileElm.draggable = true;\n    },500);\n}\n\n// performs all necessary work for a correct tile match\nconst handleCorrectMatch = (targetElm,tileElm) => {\n    removeSilhouette(tileElm);\n    targetElm.innerHTML = \"\";\n    tileElm.draggable = false;\n\n    targetElm.appendChild(tileElm);\n    playPokemonNotificationAudio(false);\n    numTilesFilled++;\n}\n\n// displays the actual pokemon on the tile\nconst removeSilhouette = (tileElm) => {\n    tileElm.classList.remove('hidden');\n    tileElm.classList.add('shown');\n}\n\n// displays the sillhoutte of the pokemon on the tile\nconst addSilhouette = (tileElm) => {\n    tileElm.classList.remove('shown');\n    tileElm.classList.add('hidden');\n}\n\n// removes the outlines from all the tile elements\nconst removeTileOutlines = () => {\n    // tile elements\n    currentTileElmArr.forEach(tileElm => {\n        tileElm.style.outline = '1px solid rgb(120, 200, 120)';\n    });\n\n    // target grid element\n    targetGridElm.style.backgroundColor = 'rgb(120, 200, 120)';\n    targetGridElm.classList.add('shimmer');\n    setTimeout(() => {\n        targetGridElm.style.backgroundColor = 'white';\n        targetGridElm.classList.remove('shimmer');\n    },BETWEEN_ROUND_DELAY_MS);\n}\n\n// updates the current score and best score\nconst updateScore = () => {\n    const currentScore = roundCount;\n    let bestScore = getPersistentBestScore();\n\n    if (currentScore > bestScore) {\n        bestScore = currentScore;\n        persistBestScore(bestScore);\n    }\n    currentScoreElm.innerText = currentScore;\n    bestScoreElm.innerText = bestScore;\n}\n\n// persists the best score to local storage\nconst persistBestScore = (score) => {\n    localStorage.setItem('bestScorePokezzle', score);\n}\n\n// retrieves the best score from local storage\nconst getPersistentBestScore = () => {\n    return localStorage.getItem('bestScorePokezzle');\n}\n\ninitPokemonDataArrAsync();\n\nsetPreGameState();\nupdateScore();\n"],"names":["pokemonDataArr","indexArrShuffled","numTilesFilled","roundCount","currentTileElmArr","currentScoreElm","document","getElementById","bestScoreElm","targetGridElm","tileContainerElm","timeTrackerElm","gameElm","startNextRound","clearTargetGridAndTileContainer","cachePokemonSprites","offsetStart","offsetEnd","calculateOffset","pokemonIdArr","slice","setupTargetGrid","cachePokemonAudio","shuffleArr","setupTileContainer","startTimer","length","generateIndexArr","indexArr","i","push","arr","randomIndex","currentIndex","Math","floor","random","row","targetRowElm","createElement","col","targetCellElm","randomId","id","innerText","name","toUpperCase","ondragover","handleOnDragOver","ondrop","handleOnDrop","appendChild","tileElmArr","tileImgElm","src","draggable","tileElm","classList","add","ondragstart","handleOnDragStart","addSilhouette","style","backgroundColor","innerHTML","currentRoundCount","setTimeout","setPreGameState","getTimeForCurrentRound","startTimerAnimation","fillElm","animation","docClickListener","removeEventListener","setInGameState","filter","pointerEvents","addEventListener","preGameModalElm","modalContentElm","body","showClickToPlay","updateScore","remove","expectedTime","forEach","pokemonId","playPokemonCryAudio","playPokemonNotificationAudio","isMuted","pokemonName","audio","Audio","muted","play","ev","dataTransfer","setData","target","preventDefault","targetElm","tileElmId","getData","targetAndTileMatch","handleIncorrectMatch","handleCorrectMatch","removeTileOutlines","targetId","tileId","split","removeSilhouette","outline","currentScore","bestScore","getPersistentBestScore","persistBestScore","score","localStorage","setItem","getItem","async","data","res","fetch","json","fetchPokemonSpeciesDataAsync","tempLength","results","map","pokemon","index","initPokemonDataArrAsync"],"version":3,"file":"index.96d21b6c.js.map"}